%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% computeIrregBdryParams() computes the interior grid points and coefficients 
% used to fill ghostcells values which impose boundary conditions at the 
% irregular boundary.
%
% USAGE:
%  function [idx_in, ...
%            idx_out, ...
%            idx_bdry, ...
%            idx_ghostcells, ...
%            idx_ghostcells_edge, ...
%            idx_ghostcells_corner, ...
%            idx_edge_bc_interp_pts, ...
%            coefs_edge_bc_interp_pts, ... 
%            coefs_edge_bc_bdry_pts, ... 
%            x_edge_bc_bdry_pts, ... 
%            y_edge_bc_bdry_pts, ...
%            idx_corner_bc_interp_pts, ... 
%            coefs_corner_bc_interp_pts] = ... 
%    computeIrregBdryParams(X, Y, N, dx, phi, 
%                           bc_interpolant_order, ...
%                           zero_level_set_tol, extrap_tol)
%
% Arguments:
% - X, Y:                  x- and y-coordinates of grid points
% - N:                     number of grid points in each coordinate direction
% - dx:                    grid spacing
% - phi:                   function whose zero level set defines the boundary
%                          of the domain.  phi must be in vector form.
% - bc_interpolant_order:  order of polynomial interpolant used to
%                          extend boundary conditions from zero level
%                          set to ghost cells.  Linear (=1), quadratic (=2)
%                          and cubic (=3) interpolation are supported.
%                          ( default = 3 )
% - zero_level_set_tol:    tolerance used to identify grid points that 
%                          should be treated as being on the zero level set.
%                          To use the default value, set zero_level_set_tol 
%                          to -1.
%                          ( default = 3*dx^2 )
% - extrap_tol:            tolerance used to deside when the grid points
%                          used for extrapolation should be shifted towards
%                          the interior of the domain.  The shift ensures
%                          that the Lagrange interpolation formula used to
%                          fill edge ghost cells is stable.  To use the 
%                          default value, set extrap_tol to -1.
%                          ( default = dx )
%  
%
% Return values:
% - idx_in:                      indices of grid points where phi < -zero_tol
% - idx_out:                     indices of grid points where phi > zero_tol
% - idx_bdry:                    indices of grid points on the boundary
%                                (i.e. abs(phi) <= zero_tol)
% - idx_ghostcells:              indices of ghostcells
% - idx_ghostcells_edge:         indices of edge ghostcells
% - idx_ghostcells_corner:       indices of corner ghostcells
% - idx_edge_bc_interp_pts:      indices of grid points used to fill
%                                edge ghost cells
% - coefs_edge_bc_interp_pts:    coefficients of extrapolation formula
%                                used to fill edge ghost cells
% - x_edge_bc_bdry_pts:          x-coordinate of boundary points used
%                                in computation of edge ghost cell values
% - y_edge_bc_bdry_pts:          y-coordinate of boundary points used
%                                in computation of edge ghost cell values
% - idx_corner_bc_interp_pts:    indices of grid points used to fill
%                                corner ghost cells
% - coefs_corner_bc_interp_pts:  coefficients of extrapolation formula
%                                used to fill corner ghost cells
%
% NOTES:
% - The number of grid points in each direction is required to be the same.
%
% - The grid spacing is assumed to be the same in both the x and y directions.
%
% - All data arrays to be consistent with the order generated by meshgrid.
%   That is, data varies fastest in the y-direction which corresponds to 
%   the 'i' index in the grid index (i,j) for each grid point.
%
% - The indices and coefficients for filling ghost cells are ordered
%   so that the i-th coefficient corresponds to the i-th index.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CHANGE LOG:
% -----------
% 2008/02:  Initial version of code extracted from solver functions.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Kevin T. Chu
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [idx_in, ...
          idx_out, ...
          idx_bdry, ...
          idx_ghostcells, ...
          idx_ghostcells_edge, ...
          idx_ghostcells_corner, ...
          idx_edge_bc_interp_pts, ...
          coefs_edge_bc_interp_pts, ... 
          coefs_edge_bc_bdry_pts, ... 
          x_edge_bc_bdry_pts, ... 
          y_edge_bc_bdry_pts, ...
          idx_corner_bc_interp_pts, ... 
          coefs_corner_bc_interp_pts] = ... 
  computeIrregBdryParams(X, Y, N, dx, phi, ...
                         bc_interpolant_order, ...
                         zero_level_set_tol, extrap_tol)


% check arguments
if (nargin < 6)
  error('computeIrregBdryParams: missing arguments');
end
if (nargin < 7 | zero_level_set_tol == -1)
  zero_level_set_tol = 3*dx^2;
end
if (nargin < 8 | extrap_tol == -1)
  extrap_tol = dx;
end

% compute indices of interior and exterior grid points
idx_in     = find(phi < -zero_level_set_tol);
idx_out    = find(phi > zero_level_set_tol);
idx_bdry       = find(abs(phi) <= zero_level_set_tol);

% convert idx to grid indices
grid_map_in   = zeros(N,N);
grid_map_out  = zeros(N,N);
grid_map_bdry = zeros(N,N);
grid_map_in(idx_in)     = 1;
grid_map_out(idx_out)   = 1;
grid_map_bdry(idx_bdry) = 1;

% compute indices of ghostcells
% NOTE: shifts are given as ordered pairs (j,i) where j is shift in
%       y-direction and i is shift in x-direction
idx_ghostcells = find( ...
    (grid_map_out > 0) ...
  & ( ([grid_map_in(2:N,:); zeros(1,N)] > 0)                     ... % (-1,0)
    | ([zeros(1,N); grid_map_in(1:N-1,:)] > 0)                   ... % (1,0)
    | ([grid_map_in(:,2:N), zeros(N,1)] > 0)                     ... % (0,-1)
    | ([zeros(N,1), grid_map_in(:,1:N-1)] > 0)                   ... % (0,1)
    | ([grid_map_in(2:N,2:N), zeros(N-1,1); zeros(1,N)] > 0)     ... % (-1,-1)
    | ([zeros(1,N); zeros(N-1,1), grid_map_in(1:N-1,1:N-1)] > 0) ... % (1,1)
    | ([zeros(1,N); grid_map_in(1:N-1,2:N), zeros(N-1,1)] > 0)   ... % (1,-1)
    | ([zeros(N-1,1), grid_map_in(2:N,1:N-1); zeros(1,N)] > 0)   ... % (-1,1)
  ) );

% compute edge and corner ghostcells
idx_ghostcells_edge = find( ...
    (grid_map_out > 0) ...
  & ( ([grid_map_in(2:N,:); zeros(1,N)] > 0)    ... % (-1,0)
    | ([zeros(1,N); grid_map_in(1:N-1,:)] > 0)  ... % (1,0)
    | ([grid_map_in(:,2:N), zeros(N,1)] > 0)    ... % (0,-1)
    | ([zeros(N,1), grid_map_in(:,1:N-1)] > 0)  ... % (0,1)
  ) );
idx_ghostcells_corner = setxor(idx_ghostcells,idx_ghostcells_edge);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% precompute several quantities required for extrapolation of 
% boundary data to ghostcells:
% (1) indices of interior neighbor points used for extrapolation,
% (2) coordinates of neighbor boundary points, 
% (3) coefficients for extrapolation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% parameters for "edge" ghostcells (i.e. ghostcells connected to 
% nearest interior grid cells by an edge)
if (bc_interpolant_order == 1)

  num_edge_ghostcells = length(idx_ghostcells_edge);
  idx_edge_bc_interp_pts = zeros(num_edge_ghostcells,1);
  coefs_edge_bc_interp_pts = zeros(num_edge_ghostcells,1);
  coefs_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  x_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  y_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);

  for i = 1:num_edge_ghostcells

    idx = idx_ghostcells_edge(i);
    x_g = X(idx); y_g = Y(idx); phi_g = phi(idx);
    success = 0;  % initialize success to false

    if ( ~success & grid_map_in(idx-1) )

      % locate point on boundary 
      phi_values = [phi(idx-2) phi(idx-1) phi(idx) phi(idx+1)];
      Y_values = [Y(idx-2) Y(idx-1) Y(idx) Y(idx+1)];
      y_b = y_g - phi_g*(Y(idx-1)-y_g)/(phi(idx-1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-1;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx-2) )
          idx_edge_bc_interp_pts(i,1) = idx-2;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b);

    end % end check for interior neighbor at (idx-1)

    if ( ~success & grid_map_in(idx+1) )

      % locate point on boundary 
      phi_values = [phi(idx-1) phi(idx) phi(idx+1) phi(idx+2)];
      Y_values = [Y(idx-1) Y(idx) Y(idx+1) Y(idx+2)];
      y_b = y_g - phi_g*(Y(idx+1)-y_g)/(phi(idx+1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+1;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx+2) )
          idx_edge_bc_interp_pts(i,1) = idx+2;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b);

    end % end check for interior neighbor at (idx+1)

    if ( ~success & grid_map_in(idx-N) )

      % locate point on boundary 
      phi_values = [phi(idx-2*N) phi(idx-N) phi(idx) phi(idx+N)];
      X_values = [X(idx-2*N) X(idx-N) X(idx) X(idx+N)];
      x_b = x_g - phi_g*(X(idx-N)-x_g)/(phi(idx-N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      if ( abs(x_1 - x_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx-2*N) )
          idx_edge_bc_interp_pts(i,1) = idx-2*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b);

    end % end check for interior neighbor at (idx-N)

    if ( grid_map_in(idx+N) )

      % locate point on boundary 
      phi_values = [phi(idx-N) phi(idx) phi(idx+N) phi(idx+2*N)];
      X_values = [X(idx-N) X(idx) X(idx+N) X(idx+2*N)];
      x_b = x_g - phi_g*(X(idx+N)-x_g)/(phi(idx+N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      if ( abs(x_1 - x_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx+2*N) )
          idx_edge_bc_interp_pts(i,1) = idx+2*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b);

    end % end check for interior neighbor at (idx+N)

    % check that interior grid point was successfully found
    if (~success)
      error('Failed to find interior grid point for edge ghostcell!!');
    end

  end % end loop over edge ghostcells

elseif (bc_interpolant_order == 2)

  num_edge_ghostcells = length(idx_ghostcells_edge);
  idx_edge_bc_interp_pts = zeros(num_edge_ghostcells,2);
  coefs_edge_bc_interp_pts = zeros(num_edge_ghostcells,2);
  coefs_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  x_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  y_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);

  for i = 1:num_edge_ghostcells

    idx = idx_ghostcells_edge(i);
    x_g = X(idx); y_g = Y(idx); phi_g = phi(idx);
    success = 0;  % initialize success to false

    if ( ~success & grid_map_in(idx-1) )

      % locate point on boundary 
      phi_values = [phi(idx-2) phi(idx-1) phi(idx) phi(idx+1)];
      Y_values = [Y(idx-2) Y(idx-1) Y(idx) Y(idx+1)];
      y_b = y_g - phi_g*(Y(idx-1)-y_g)/(phi(idx-1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-1;
      idx_edge_bc_interp_pts(i,2) = idx-2;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      y_2 = Y(idx_edge_bc_interp_pts(i,2));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else 
        if ( grid_map_in(idx-2) & grid_map_in(idx-3) )
          idx_edge_bc_interp_pts(i,1) = idx-2;
          idx_edge_bc_interp_pts(i,2) = idx-3;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          y_2 = Y(idx_edge_bc_interp_pts(i,2));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1) ...
                                    * (y_g-y_2)/(y_b-y_2);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b) ...
                                    * (y_g-y_2)/(y_1-y_2);
      coefs_edge_bc_interp_pts(i,2) = (y_g-y_b)/(y_2-y_b) ...
                                    * (y_g-y_1)/(y_2-y_1);

    end % end check for interior neighbor at (idx-1)

    if ( ~success & grid_map_in(idx+1) )

      % locate point on boundary 
      phi_values = [phi(idx-1) phi(idx) phi(idx+1) phi(idx+2)];
      Y_values = [Y(idx-1) Y(idx) Y(idx+1) Y(idx+2)];
      y_b = y_g - phi_g*(Y(idx+1)-y_g)/(phi(idx+1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+1;
      idx_edge_bc_interp_pts(i,2) = idx+2;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      y_2 = Y(idx_edge_bc_interp_pts(i,2));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx+2) & grid_map_in(idx+3) )
          idx_edge_bc_interp_pts(i,1) = idx+2;
          idx_edge_bc_interp_pts(i,2) = idx+3;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          y_2 = Y(idx_edge_bc_interp_pts(i,2));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1) ...
                                    * (y_g-y_2)/(y_b-y_2);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b) ...
                                    * (y_g-y_2)/(y_1-y_2);
      coefs_edge_bc_interp_pts(i,2) = (y_g-y_b)/(y_2-y_b) ...
                                    * (y_g-y_1)/(y_2-y_1);

    end % end check for interior neighbor at (idx+1)

    if ( ~success & grid_map_in(idx-N) )

      % locate point on boundary 
      phi_values = [phi(idx-2*N) phi(idx-N) phi(idx) phi(idx+N)];
      X_values = [X(idx-2*N) X(idx-N) X(idx) X(idx+N)];
      x_b = x_g - phi_g*(X(idx-N)-x_g)/(phi(idx-N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-N;
      idx_edge_bc_interp_pts(i,2) = idx-2*N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      x_2 = X(idx_edge_bc_interp_pts(i,2));
      if ( abs(x_1 - x_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx-2*N) & grid_map_in(idx-3*N) )
          idx_edge_bc_interp_pts(i,1) = idx-2*N;
          idx_edge_bc_interp_pts(i,2) = idx-3*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          x_2 = X(idx_edge_bc_interp_pts(i,2));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1) ...
                                    * (x_g-x_2)/(x_b-x_2);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b) ...
                                    * (x_g-x_2)/(x_1-x_2);
      coefs_edge_bc_interp_pts(i,2) = (x_g-x_b)/(x_2-x_b) ...
                                    * (x_g-x_1)/(x_2-x_1);

    end % end check for interior neighbor at (idx-N)

    if ( ~success & grid_map_in(idx+N) )

      % locate point on boundary 
      phi_values = [phi(idx-N) phi(idx) phi(idx+N) phi(idx+2*N)];
      X_values = [X(idx-N) X(idx) X(idx+N) X(idx+2*N)];
      x_b = x_g - phi_g*(X(idx+N)-x_g)/(phi(idx+N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+N;
      idx_edge_bc_interp_pts(i,2) = idx+2*N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      x_2 = X(idx_edge_bc_interp_pts(i,2));
      if ( abs(x_1 - x_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx+2*N) & grid_map_in(idx+3*N) )
          idx_edge_bc_interp_pts(i,1) = idx+2*N;
          idx_edge_bc_interp_pts(i,2) = idx+3*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          x_2 = X(idx_edge_bc_interp_pts(i,2));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1) ...
                                    * (x_g-x_2)/(x_b-x_2);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b) ...
                                    * (x_g-x_2)/(x_1-x_2);
      coefs_edge_bc_interp_pts(i,2) = (x_g-x_b)/(x_2-x_b) ...
                                    * (x_g-x_1)/(x_2-x_1);

    end % end check for interior neighbor at (idx+N)

    % check that interior grid point was successfully found
    if (~success)
      error('Failed to find interior grid point for edge ghostcell!!');
    end

  end % end loop over edge ghostcells

elseif (bc_interpolant_order == 3)

  num_edge_ghostcells = length(idx_ghostcells_edge);
  idx_edge_bc_interp_pts = zeros(num_edge_ghostcells,3);
  coefs_edge_bc_interp_pts = zeros(num_edge_ghostcells,3);
  coefs_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  x_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);
  y_edge_bc_bdry_pts = zeros(num_edge_ghostcells,1);

  for i = 1:num_edge_ghostcells

    idx = idx_ghostcells_edge(i);
    x_g = X(idx); y_g = Y(idx); phi_g = phi(idx);
    success = 0;  % initialize success to false

    if ( ~success & grid_map_in(idx-1) )

      % locate point on boundary 
      phi_values = [phi(idx-2) phi(idx-1) phi(idx) phi(idx+1)];
      Y_values = [Y(idx-2) Y(idx-1) Y(idx) Y(idx+1)];
      y_b = y_g - phi_g*(Y(idx-1)-y_g)/(phi(idx-1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-1;
      idx_edge_bc_interp_pts(i,2) = idx-2;
      idx_edge_bc_interp_pts(i,3) = idx-3;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      y_2 = Y(idx_edge_bc_interp_pts(i,2));
      y_3 = Y(idx_edge_bc_interp_pts(i,3));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx-2) & grid_map_in(idx-3) & grid_map_in(idx-4) )
          idx_edge_bc_interp_pts(i,1) = idx-2;
          idx_edge_bc_interp_pts(i,2) = idx-3;
          idx_edge_bc_interp_pts(i,3) = idx-4;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          y_2 = Y(idx_edge_bc_interp_pts(i,2));
          y_3 = Y(idx_edge_bc_interp_pts(i,3));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1) ...
                                    * (y_g-y_2)/(y_b-y_2) ...
                                    * (y_g-y_3)/(y_b-y_3);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b) ...
                                    * (y_g-y_2)/(y_1-y_2) ...
                                    * (y_g-y_3)/(y_1-y_3);
      coefs_edge_bc_interp_pts(i,2) = (y_g-y_b)/(y_2-y_b) ...
                                    * (y_g-y_1)/(y_2-y_1) ...
                                    * (y_g-y_3)/(y_2-y_3);
      coefs_edge_bc_interp_pts(i,3) = (y_g-y_b)/(y_3-y_b) ...
                                    * (y_g-y_1)/(y_3-y_1) ...
                                    * (y_g-y_2)/(y_3-y_2);

    end % end check for interior neighbor at (idx-1)

    if ( ~success & grid_map_in(idx+1) )

      % locate point on boundary 
      phi_values = [phi(idx-1) phi(idx) phi(idx+1) phi(idx+2)];
      Y_values = [Y(idx-1) Y(idx) Y(idx+1) Y(idx+2)];
      y_b = y_g - phi_g*(Y(idx+1)-y_g)/(phi(idx+1)-phi_g);
      x_edge_bc_bdry_pts(i) = x_g;
      y_edge_bc_bdry_pts(i) = y_b;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+1;
      idx_edge_bc_interp_pts(i,2) = idx+2;
      idx_edge_bc_interp_pts(i,3) = idx+3;
      y_1 = Y(idx_edge_bc_interp_pts(i,1));
      y_2 = Y(idx_edge_bc_interp_pts(i,2));
      y_3 = Y(idx_edge_bc_interp_pts(i,3));
      if ( abs(y_1 - y_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx+2) & grid_map_in(idx+3) & grid_map_in(idx+4) )
          idx_edge_bc_interp_pts(i,1) = idx+2;
          idx_edge_bc_interp_pts(i,2) = idx+3;
          idx_edge_bc_interp_pts(i,3) = idx+4;
          y_1 = Y(idx_edge_bc_interp_pts(i,1));
          y_2 = Y(idx_edge_bc_interp_pts(i,2));
          y_3 = Y(idx_edge_bc_interp_pts(i,3));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (y_g-y_1)/(y_b-y_1) ...
                                    * (y_g-y_2)/(y_b-y_2) ...
                                    * (y_g-y_3)/(y_b-y_3);
      coefs_edge_bc_interp_pts(i,1) = (y_g-y_b)/(y_1-y_b) ...
                                    * (y_g-y_2)/(y_1-y_2) ...
                                    * (y_g-y_3)/(y_1-y_3);
      coefs_edge_bc_interp_pts(i,2) = (y_g-y_b)/(y_2-y_b) ...
                                    * (y_g-y_1)/(y_2-y_1) ...
                                    * (y_g-y_3)/(y_2-y_3);
      coefs_edge_bc_interp_pts(i,3) = (y_g-y_b)/(y_3-y_b) ...
                                    * (y_g-y_1)/(y_3-y_1) ...
                                    * (y_g-y_2)/(y_3-y_2);

    end % end check for interior neighbor at (idx+1)

    if ( ~success & grid_map_in(idx-N) )

      % locate point on boundary 
      phi_values = [phi(idx-2*N) phi(idx-N) phi(idx) phi(idx+N)];
      X_values = [X(idx-2*N) X(idx-N) X(idx) X(idx+N)];
      x_b = x_g - phi_g*(X(idx-N)-x_g)/(phi(idx-N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx-N;
      idx_edge_bc_interp_pts(i,2) = idx-2*N;
      idx_edge_bc_interp_pts(i,3) = idx-3*N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      x_2 = X(idx_edge_bc_interp_pts(i,2));
      x_3 = X(idx_edge_bc_interp_pts(i,3));
      if ( abs(x_1 - x_b) > extrap_tol )
        success = 1;
      else
        if ( grid_map_in(idx-2*N) & grid_map_in(idx-3*N) ...
           & grid_map_in(idx-4*N) )
          idx_edge_bc_interp_pts(i,1) = idx-2*N;
          idx_edge_bc_interp_pts(i,2) = idx-3*N;
          idx_edge_bc_interp_pts(i,3) = idx-4*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          x_2 = X(idx_edge_bc_interp_pts(i,2));
          x_3 = X(idx_edge_bc_interp_pts(i,3));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1) ...
                                    * (x_g-x_2)/(x_b-x_2) ...
                                    * (x_g-x_3)/(x_b-x_3);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b) ...
                                    * (x_g-x_2)/(x_1-x_2) ...
                                    * (x_g-x_3)/(x_1-x_3);
      coefs_edge_bc_interp_pts(i,2) = (x_g-x_b)/(x_2-x_b) ...
                                    * (x_g-x_1)/(x_2-x_1) ...
                                    * (x_g-x_3)/(x_2-x_3);
      coefs_edge_bc_interp_pts(i,3) = (x_g-x_b)/(x_3-x_b) ...
                                    * (x_g-x_1)/(x_3-x_1) ...
                                    * (x_g-x_2)/(x_3-x_2);

    end % end check for interior neighbor at (idx-N)

    if ( ~success & grid_map_in(idx+N) )

      % locate point on boundary 
      phi_values = [phi(idx-N) phi(idx) phi(idx+N) phi(idx+2*N)];
      X_values = [X(idx-N) X(idx) X(idx+N) X(idx+2*N)];
      x_b = x_g - phi_g*(X(idx+N)-x_g)/(phi(idx+N)-phi_g);
      x_edge_bc_bdry_pts(i) = x_b;
      y_edge_bc_bdry_pts(i) = y_g;

      % compute positions and indices of interpolation points
      idx_edge_bc_interp_pts(i,1) = idx+N;
      idx_edge_bc_interp_pts(i,2) = idx+2*N;
      idx_edge_bc_interp_pts(i,3) = idx+3*N;
      x_1 = X(idx_edge_bc_interp_pts(i,1));
      x_2 = X(idx_edge_bc_interp_pts(i,2));
      x_3 = X(idx_edge_bc_interp_pts(i,3));
      if ( abs(x_1 - x_b) > extrap_tol)
        success = 1;
      else
        if ( grid_map_in(idx+2*N) & grid_map_in(idx+3*N) ...
           & grid_map_in(idx+4*N) )
          idx_edge_bc_interp_pts(i,1) = idx+2*N;
          idx_edge_bc_interp_pts(i,2) = idx+3*N;
          idx_edge_bc_interp_pts(i,3) = idx+4*N;
          x_1 = X(idx_edge_bc_interp_pts(i,1));
          x_2 = X(idx_edge_bc_interp_pts(i,2));
          x_3 = X(idx_edge_bc_interp_pts(i,3));
          success = 1;
        end
      end

      % compute coefficients in interpolation formula
      coefs_edge_bc_bdry_pts(i,1)   = (x_g-x_1)/(x_b-x_1) ...
                                    * (x_g-x_2)/(x_b-x_2) ...
                                    * (x_g-x_3)/(x_b-x_3);
      coefs_edge_bc_interp_pts(i,1) = (x_g-x_b)/(x_1-x_b) ...
                                    * (x_g-x_2)/(x_1-x_2) ...
                                    * (x_g-x_3)/(x_1-x_3);
      coefs_edge_bc_interp_pts(i,2) = (x_g-x_b)/(x_2-x_b) ...
                                    * (x_g-x_1)/(x_2-x_1) ...
                                    * (x_g-x_3)/(x_2-x_3);
      coefs_edge_bc_interp_pts(i,3) = (x_g-x_b)/(x_3-x_b) ...
                                    * (x_g-x_1)/(x_3-x_1) ...
                                    * (x_g-x_2)/(x_3-x_2);

    end % end check for interior neighbor at (idx+N)

    % check that interior grid point was successfully found
    if (~success)
      error('Failed to find interior grid point for edge ghostcell!!');
    end

  end % end loop over edge ghostcells

else

  error('Invalid order for polynomial interpolant.  Valid orders = 1, 2, and 3.');

end

% parameters for "corner" ghostcells (i.e. ghostcells connected to 
% nearest interior grid cells by the diagonal of a grid cell)
num_corner_ghostcells = length(idx_ghostcells_corner);
idx_corner_bc_interp_pts = zeros(num_corner_ghostcells,3);
coefs_corner_bc_interp_pts = zeros(num_corner_ghostcells,3);

if ( bc_interpolant_order == 1 ...
   | bc_interpolant_order == 2 )

  % linear extrapolation for corner points is sufficient
  % to obtain a second- or third-order accurate solution

  for i = 1:num_corner_ghostcells

    idx = idx_ghostcells_corner(i);
    x_g = X(idx); y_g = Y(idx); phi_g = phi(idx);

    % compute coefficients in interpolation formula
    coefs_corner_bc_interp_pts(i,1) = -1;
    coefs_corner_bc_interp_pts(i,2) = 1;
    coefs_corner_bc_interp_pts(i,3) = 1;

    % compute indices of interpolation points
    if ( grid_map_in(idx-1-N) )

      idx_corner_bc_interp_pts(i,1) = idx-1-N;
      idx_corner_bc_interp_pts(i,2) = idx-N;
      idx_corner_bc_interp_pts(i,3) = idx-1;

    elseif ( grid_map_in(idx-1+N) )

      idx_corner_bc_interp_pts(i,1) = idx-1+N;
      idx_corner_bc_interp_pts(i,2) = idx+N;
      idx_corner_bc_interp_pts(i,3) = idx-1;

    elseif ( grid_map_in(idx+1-N) )

      idx_corner_bc_interp_pts(i,1) = idx+1-N;
      idx_corner_bc_interp_pts(i,2) = idx-N;
      idx_corner_bc_interp_pts(i,3) = idx+1;

    elseif ( grid_map_in(idx+1+N) )

      idx_corner_bc_interp_pts(i,1) = idx+1+N;
      idx_corner_bc_interp_pts(i,2) = idx+N;
      idx_corner_bc_interp_pts(i,3) = idx+1;

    end % switch over location of interface relative to ghost cell

  end % end loop over corner ghostcells

elseif ( bc_interpolant_order == 3 ) 

  % quadratic extrapolation for corner points is required 
  % to obtain a fourth-order accurate solution

  num_corner_ghostcells = length(idx_ghostcells_corner);
  idx_corner_bc_interp_pts = zeros(num_corner_ghostcells,8);
  coefs_corner_bc_interp_pts = zeros(num_corner_ghostcells,8);

  for i = 1:num_corner_ghostcells

    idx = idx_ghostcells_corner(i);
    x_g = X(idx); y_g = Y(idx); phi_g = phi(idx);
    success = 0;  % initialize success to false

    % compute coefficients in interpolation formula
    coefs_corner_bc_interp_pts(i,1) = 2;
    coefs_corner_bc_interp_pts(i,2) = 2;
    coefs_corner_bc_interp_pts(i,3) = -1;
    coefs_corner_bc_interp_pts(i,4) = -4;
    coefs_corner_bc_interp_pts(i,5) = -1;
    coefs_corner_bc_interp_pts(i,6) = 2;
    coefs_corner_bc_interp_pts(i,7) = 2;
    coefs_corner_bc_interp_pts(i,8) = -1;

    % compute positions and indices of interpolation points
    if ( grid_map_in(idx-1-N) )

      idx_corner_bc_interp_pts(i,1) = idx-1;
      idx_corner_bc_interp_pts(i,2) = idx-N;
      idx_corner_bc_interp_pts(i,3) = idx-2;
      idx_corner_bc_interp_pts(i,4) = idx-1-N;
      idx_corner_bc_interp_pts(i,5) = idx-2*N;
      idx_corner_bc_interp_pts(i,6) = idx-2-N;
      idx_corner_bc_interp_pts(i,7) = idx-1-2*N;
      idx_corner_bc_interp_pts(i,8) = idx-2-2*N;
      success = 1;

    elseif ( grid_map_in(idx-1+N) )

      idx_corner_bc_interp_pts(i,1) = idx-1;
      idx_corner_bc_interp_pts(i,2) = idx+N;
      idx_corner_bc_interp_pts(i,3) = idx-2;
      idx_corner_bc_interp_pts(i,4) = idx-1+N;
      idx_corner_bc_interp_pts(i,5) = idx+2*N;
      idx_corner_bc_interp_pts(i,6) = idx-2+N;
      idx_corner_bc_interp_pts(i,7) = idx-1+2*N;
      idx_corner_bc_interp_pts(i,8) = idx-2+2*N;
      success = 1;
    
    elseif ( grid_map_in(idx+1-N) )
      
      idx_corner_bc_interp_pts(i,1) = idx+1;
      idx_corner_bc_interp_pts(i,2) = idx-N;
      idx_corner_bc_interp_pts(i,3) = idx+2;
      idx_corner_bc_interp_pts(i,4) = idx+1-N;
      idx_corner_bc_interp_pts(i,5) = idx-2*N;
      idx_corner_bc_interp_pts(i,6) = idx+2-N;
      idx_corner_bc_interp_pts(i,7) = idx+1-2*N;
      idx_corner_bc_interp_pts(i,8) = idx+2-2*N;
      success = 1;
    
    elseif ( grid_map_in(idx+1+N) )
      
      idx_corner_bc_interp_pts(i,1) = idx+1;
      idx_corner_bc_interp_pts(i,2) = idx+N;
      idx_corner_bc_interp_pts(i,3) = idx+2;
      idx_corner_bc_interp_pts(i,4) = idx+1+N;
      idx_corner_bc_interp_pts(i,5) = idx+2*N;
      idx_corner_bc_interp_pts(i,6) = idx+2+N;
      idx_corner_bc_interp_pts(i,7) = idx+1+2*N;
      idx_corner_bc_interp_pts(i,8) = idx+2+2*N;
      success = 1;
    
    end % switch over location of interface relative to ghost cell
  
    % check that interior grid point was successfully found
    if (~success)
      error('Failed to find interior grid point for corner ghostcell!!');
    end

  end % end loop over corner ghostcells

else
    error('Invalid order for polynomial interpolant.  Valid orders = 1, 2, and 3.');

end
